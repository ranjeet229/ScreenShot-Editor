<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Privacy-First Screenshot Editor</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }

    .container {
      background: white;
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      max-width: 1200px;
      width: 100%;
      overflow: hidden;
    }

    .header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 24px;
      text-align: center;
    }

    .header h1 {
      font-size: 28px;
      margin-bottom: 8px;
    }

    .header p {
      opacity: 0.9;
      font-size: 14px;
    }

    .toolbar {
      display: flex;
      gap: 8px;
      padding: 16px;
      background: #f8f9fa;
      border-bottom: 1px solid #e9ecef;
      flex-wrap: wrap;
      align-items: center;
    }

    .tool-group {
      display: flex;
      gap: 8px;
      padding-right: 16px;
      border-right: 1px solid #dee2e6;
    }

    .tool-group:last-child {
      border-right: none;
    }

    .btn {
      padding: 10px 16px;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }

    .btn:active {
      transform: translateY(0);
    }

    .btn-tool {
      background: white;
      border: 2px solid #dee2e6;
      color: #495057;
    }

    .btn-tool.active {
      background: #667eea;
      color: white;
      border-color: #667eea;
    }

    .btn-primary {
      background: #667eea;
      color: white;
    }

    .btn-success {
      background: #51cf66;
      color: white;
    }

    .btn-secondary {
      background: #868e96;
      color: white;
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .canvas-container {
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 500px;
      background: #f8f9fa;
      padding: 24px;
    }

    .drop-zone {
      border: 3px dashed #adb5bd;
      border-radius: 12px;
      padding: 60px;
      text-align: center;
      color: #868e96;
      max-width: 600px;
    }

    .drop-zone.drag-over {
      border-color: #667eea;
      background: rgba(102, 126, 234, 0.05);
      color: #667eea;
    }

    .drop-zone h2 {
      font-size: 24px;
      margin-bottom: 12px;
    }

    .drop-zone p {
      font-size: 16px;
      margin-bottom: 8px;
    }

    canvas {
      max-width: 100%;
      max-height: 70vh;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      cursor: crosshair;
      display: block;
    }

    .hidden {
      display: none !important;
    }

    .slider-group {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 0 16px;
    }

    .slider-group label {
      font-size: 14px;
      color: #495057;
      font-weight: 500;
    }

    input[type="range"] {
      width: 100px;
    }

    .size-value {
      font-size: 14px;
      color: #667eea;
      font-weight: 600;
      min-width: 30px;
    }

    .color-picker {
      width: 40px;
      height: 40px;
      border: 2px solid #dee2e6;
      border-radius: 8px;
      cursor: pointer;
    }

    @media (max-width: 768px) {
      .toolbar {
        flex-direction: column;
        align-items: stretch;
      }

      .tool-group {
        border-right: none;
        border-bottom: 1px solid #dee2e6;
        padding-bottom: 8px;
        padding-right: 0;
      }

      .tool-group:last-child {
        border-bottom: none;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üîí Privacy-First Screenshot Editor</h1>
      <p>Edit screenshots locally in your browser. No uploads, no tracking.</p>
    </div>

    <div class="toolbar hidden" id="toolbar">
      <div class="tool-group">
        <button class="btn btn-tool active" data-tool="blur" title="Blur Tool (B)">
          <span>üå´Ô∏è</span> Blur
        </button>
        <button class="btn btn-tool" data-tool="pixelate" title="Pixelate Tool (P)">
          <span>‚óºÔ∏è</span> Pixelate
        </button>
        <button class="btn btn-tool" data-tool="rectangle" title="Blackout Rectangle (R)">
          <span>‚¨õ</span> Blackout
        </button>
        <button class="btn btn-tool" data-tool="arrow" title="Arrow Tool (A)">
          <span>‚û°Ô∏è</span> Arrow
        </button>
        <button class="btn btn-tool" data-tool="text" title="Text Tool (T)">
          <span>üìù</span> Text
        </button>
      </div>

      <div class="tool-group slider-group">
        <label>Size:</label>
        <input type="range" id="brushSize" min="5" max="100" value="30">
        <span class="size-value" id="sizeValue">30</span>
      </div>

      <div class="tool-group">
        <input type="color" id="colorPicker" class="color-picker" value="#ff0000" title="Color">
      </div>

      <div class="tool-group">
        <button class="btn btn-secondary" id="undoBtn" disabled title="Undo (Ctrl+Z)">
          ‚Ü∂ Undo
        </button>
        <button class="btn btn-secondary" id="redoBtn" disabled title="Redo (Ctrl+Y)">
          ‚Ü∑ Redo
        </button>
      </div>

      <div class="tool-group">
        <button class="btn btn-success" id="copyBtn" title="Copy to Clipboard">
          üìã Copy
        </button>
        <button class="btn btn-primary" id="downloadBtn" title="Download PNG">
          üíæ Download
        </button>
        <button class="btn btn-secondary" id="newBtn" title="Load New Image">
          üñºÔ∏è New Image
        </button>
      </div>
    </div>

    <div class="canvas-container" id="canvasContainer">
      <div class="drop-zone" id="dropZone">
        <h2>üì∏ Drop an Image or Press Ctrl+V</h2>
        <p>Your image never leaves your device</p>
        <p style="font-size: 14px; margin-top: 12px;">Supports: PNG, JPG, GIF, WebP</p>
      </div>
      <canvas id="canvas" class="hidden"></canvas>
    </div>
  </div>

  <script>
    class ScreenshotEditor {
      constructor() {
        this.canvas = document.getElementById('canvas');
        this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });
        this.dropZone = document.getElementById('dropZone');
        this.toolbar = document.getElementById('toolbar');
        this.canvasContainer = document.getElementById('canvasContainer');
        
        this.currentTool = 'blur';
        this.brushSize = 30;
        this.color = '#ff0000';
        this.isDrawing = false;
        this.startX = 0;
        this.startY = 0;
        this.currentX = 0;
        this.currentY = 0;
        
        this.undoStack = [];
        this.redoStack = [];
        this.maxStackSize = 50;
        
        this.originalImage = null;
        this.tempCanvas = document.createElement('canvas');
        this.tempCtx = this.tempCanvas.getContext('2d', { willReadFrequently: true });
        
        this.init();
      }

      init() {
        this.setupEventListeners();
        this.setupKeyboardShortcuts();
      }

      setupEventListeners() {
        document.addEventListener('paste', (e) => this.handlePaste(e));
        this.dropZone.addEventListener('dragover', (e) => this.handleDragOver(e));
        this.dropZone.addEventListener('dragleave', (e) => this.handleDragLeave(e));
        this.dropZone.addEventListener('drop', (e) => this.handleDrop(e));
        
        this.canvas.addEventListener('mousedown', (e) => this.startDrawing(e));
        this.canvas.addEventListener('mousemove', (e) => this.draw(e));
        this.canvas.addEventListener('mouseup', () => this.stopDrawing());
        this.canvas.addEventListener('mouseout', () => this.stopDrawing());
        
        document.querySelectorAll('[data-tool]').forEach(btn => {
          btn.addEventListener('click', (e) => this.selectTool(e.target.closest('[data-tool]').dataset.tool));
        });
        
        document.getElementById('brushSize').addEventListener('input', (e) => {
          this.brushSize = parseInt(e.target.value);
          document.getElementById('sizeValue').textContent = this.brushSize;
        });
        
        document.getElementById('colorPicker').addEventListener('input', (e) => {
          this.color = e.target.value;
        });
        
        document.getElementById('undoBtn').addEventListener('click', () => this.undo());
        document.getElementById('redoBtn').addEventListener('click', () => this.redo());
        document.getElementById('copyBtn').addEventListener('click', () => this.copyToClipboard());
        document.getElementById('downloadBtn').addEventListener('click', () => this.downloadImage());
        document.getElementById('newBtn').addEventListener('click', () => this.loadNewImage());
      }

      setupKeyboardShortcuts() {
        document.addEventListener('keydown', (e) => {
          if (e.ctrlKey || e.metaKey) {
            if (e.key === 'z') {
              e.preventDefault();
              this.undo();
            } else if (e.key === 'y' || (e.shiftKey && e.key === 'z')) {
              e.preventDefault();
              this.redo();
            }
          }
          
          const toolMap = { b: 'blur', p: 'pixelate', r: 'rectangle', a: 'arrow', t: 'text' };
          if (toolMap[e.key.toLowerCase()] && !e.ctrlKey && !e.metaKey) {
            this.selectTool(toolMap[e.key.toLowerCase()]);
          }
        });
      }

      selectTool(tool) {
        this.currentTool = tool;
        document.querySelectorAll('[data-tool]').forEach(btn => btn.classList.remove('active'));
        document.querySelector(`[data-tool="${tool}"]`).classList.add('active');
      }

      handlePaste(e) {
        e.preventDefault();
        const items = e.clipboardData.items;
        
        for (let i = 0; i < items.length; i++) {
          if (items[i].type.indexOf('image') !== -1) {
            const blob = items[i].getAsFile();
            this.loadImageFromBlob(blob);
            return;
          }
        }
      }

      handleDragOver(e) {
        e.preventDefault();
        this.dropZone.classList.add('drag-over');
      }

      handleDragLeave(e) {
        e.preventDefault();
        this.dropZone.classList.remove('drag-over');
      }

      handleDrop(e) {
        e.preventDefault();
        this.dropZone.classList.remove('drag-over');
        
        const files = e.dataTransfer.files;
        if (files.length > 0 && files[0].type.startsWith('image/')) {
          this.loadImageFromBlob(files[0]);
        }
      }

      loadImageFromBlob(blob) {
        const reader = new FileReader();
        reader.onload = (e) => {
          const img = new Image();
          img.onload = () => {
            this.originalImage = img;
            this.setupCanvas(img);
            this.saveState();
          };
          img.src = e.target.result;
        };
        reader.readAsDataURL(blob);
      }

      setupCanvas(img) {
        this.canvas.width = img.width;
        this.canvas.height = img.height;
        this.tempCanvas.width = img.width;
        this.tempCanvas.height = img.height;
        
        this.ctx.drawImage(img, 0, 0);
        
        this.dropZone.classList.add('hidden');
        this.canvas.classList.remove('hidden');
        this.toolbar.classList.remove('hidden');
      }

      getMousePos(e) {
        const rect = this.canvas.getBoundingClientRect();
        const scaleX = this.canvas.width / rect.width;
        const scaleY = this.canvas.height / rect.height;
        
        return {
          x: (e.clientX - rect.left) * scaleX,
          y: (e.clientY - rect.top) * scaleY
        };
      }

      startDrawing(e) {
        this.isDrawing = true;
        const pos = this.getMousePos(e);
        this.startX = pos.x;
        this.startY = pos.y;
        this.currentX = pos.x;
        this.currentY = pos.y;
        
        this.tempCtx.clearRect(0, 0, this.tempCanvas.width, this.tempCanvas.height);
        this.tempCtx.drawImage(this.canvas, 0, 0);
        
        if (this.currentTool === 'blur' || this.currentTool === 'pixelate') {
          this.applyBrushEffect(pos.x, pos.y);
        } else if (this.currentTool === 'text') {
          this.addText(pos.x, pos.y);
        }
      }

      draw(e) {
        if (!this.isDrawing) return;
        
        const pos = this.getMousePos(e);
        this.currentX = pos.x;
        this.currentY = pos.y;
        
        if (this.currentTool === 'blur' || this.currentTool === 'pixelate') {
          this.applyBrushEffect(pos.x, pos.y);
        } else if (this.currentTool === 'rectangle' || this.currentTool === 'arrow') {
          this.drawPreview();
        }
      }

      stopDrawing() {
        if (!this.isDrawing) return;
        this.isDrawing = false;
        
        if (this.currentTool === 'rectangle') {
          this.drawRectangle();
        } else if (this.currentTool === 'arrow') {
          this.drawArrow();
        }
        
        this.saveState();
      }

      applyBrushEffect(x, y) {
        const radius = this.brushSize / 2;
        const imageData = this.tempCtx.getImageData(
          Math.max(0, x - radius),
          Math.max(0, y - radius),
          Math.min(this.canvas.width, radius * 2),
          Math.min(this.canvas.height, radius * 2)
        );
        
        if (this.currentTool === 'blur') {
          this.applyBlur(imageData);
        } else if (this.currentTool === 'pixelate') {
          this.applyPixelate(imageData);
        }
        
        this.ctx.putImageData(imageData, Math.max(0, x - radius), Math.max(0, y - radius));
      }

      applyBlur(imageData) {
        const pixels = imageData.data;
        const width = imageData.width;
        const height = imageData.height;
        const blurRadius = 3;
        
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            let r = 0, g = 0, b = 0, count = 0;
            
            for (let ky = -blurRadius; ky <= blurRadius; ky++) {
              for (let kx = -blurRadius; kx <= blurRadius; kx++) {
                const px = x + kx;
                const py = y + ky;
                
                if (px >= 0 && px < width && py >= 0 && py < height) {
                  const idx = (py * width + px) * 4;
                  r += pixels[idx];
                  g += pixels[idx + 1];
                  b += pixels[idx + 2];
                  count++;
                }
              }
            }
            
            const idx = (y * width + x) * 4;
            pixels[idx] = r / count;
            pixels[idx + 1] = g / count;
            pixels[idx + 2] = b / count;
          }
        }
      }

      applyPixelate(imageData) {
        const pixels = imageData.data;
        const width = imageData.width;
        const height = imageData.height;
        const blockSize = 10;
        
        for (let y = 0; y < height; y += blockSize) {
          for (let x = 0; x < width; x += blockSize) {
            let r = 0, g = 0, b = 0, count = 0;
            
            for (let by = 0; by < blockSize && y + by < height; by++) {
              for (let bx = 0; bx < blockSize && x + bx < width; bx++) {
                const idx = ((y + by) * width + (x + bx)) * 4;
                r += pixels[idx];
                g += pixels[idx + 1];
                b += pixels[idx + 2];
                count++;
              }
            }
            
            r = Math.floor(r / count);
            g = Math.floor(g / count);
            b = Math.floor(b / count);
            
            for (let by = 0; by < blockSize && y + by < height; by++) {
              for (let bx = 0; bx < blockSize && x + bx < width; bx++) {
                const idx = ((y + by) * width + (x + bx)) * 4;
                pixels[idx] = r;
                pixels[idx + 1] = g;
                pixels[idx + 2] = b;
              }
            }
          }
        }
      }

      drawPreview() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.drawImage(this.tempCanvas, 0, 0);
        
        if (this.currentTool === 'rectangle') {
          this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
          this.ctx.fillRect(
            this.startX,
            this.startY,
            this.currentX - this.startX,
            this.currentY - this.startY
          );
        } else if (this.currentTool === 'arrow') {
          this.ctx.strokeStyle = this.color;
          this.ctx.fillStyle = this.color;
          this.ctx.lineWidth = 3;
          this.drawArrowShape(this.startX, this.startY, this.currentX, this.currentY);
        }
      }

      drawRectangle() {
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        this.ctx.fillRect(
          this.startX,
          this.startY,
          this.currentX - this.startX,
          this.currentY - this.startY
        );
      }

      drawArrow() {
        this.ctx.strokeStyle = this.color;
        this.ctx.fillStyle = this.color;
        this.ctx.lineWidth = 3;
        this.drawArrowShape(this.startX, this.startY, this.currentX, this.currentY);
      }

      drawArrowShape(x1, y1, x2, y2) {
        const angle = Math.atan2(y2 - y1, x2 - x1);
        const headLen = 20;
        
        this.ctx.beginPath();
        this.ctx.moveTo(x1, y1);
        this.ctx.lineTo(x2, y2);
        this.ctx.stroke();
        
        this.ctx.beginPath();
        this.ctx.moveTo(x2, y2);
        this.ctx.lineTo(
          x2 - headLen * Math.cos(angle - Math.PI / 6),
          y2 - headLen * Math.sin(angle - Math.PI / 6)
        );
        this.ctx.lineTo(
          x2 - headLen * Math.cos(angle + Math.PI / 6),
          y2 - headLen * Math.sin(angle + Math.PI / 6)
        );
        this.ctx.closePath();
        this.ctx.fill();
      }

      addText(x, y) {
        const text = prompt('Enter text:');
        if (text) {
          this.ctx.font = `${this.brushSize}px Arial`;
          this.ctx.fillStyle = this.color;
          this.ctx.fillText(text, x, y);
          this.saveState();
        }
        this.isDrawing = false;
      }

      saveState() {
        if (this.undoStack.length >= this.maxStackSize) {
          this.undoStack.shift();
        }
        
        this.undoStack.push(this.canvas.toDataURL());
        this.redoStack = [];
        this.updateUndoRedoButtons();
      }

      undo() {
        if (this.undoStack.length <= 1) return;
        
        const currentState = this.undoStack.pop();
        this.redoStack.push(currentState);
        
        const previousState = this.undoStack[this.undoStack.length - 1];
        this.restoreState(previousState);
        this.updateUndoRedoButtons();
      }

      redo() {
        if (this.redoStack.length === 0) return;
        
        const state = this.redoStack.pop();
        this.undoStack.push(state);
        this.restoreState(state);
        this.updateUndoRedoButtons();
      }

      restoreState(dataUrl) {
        const img = new Image();
        img.onload = () => {
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
          this.ctx.drawImage(img, 0, 0);
        };
        img.src = dataUrl;
      }

      updateUndoRedoButtons() {
        document.getElementById('undoBtn').disabled = this.undoStack.length <= 1;
        document.getElementById('redoBtn').disabled = this.redoStack.length === 0;
      }

      async copyToClipboard() {
        try {
          this.canvas.toBlob(async (blob) => {
            await navigator.clipboard.write([
              new ClipboardItem({ 'image/png': blob })
            ]);
            this.showNotification('‚úì Copied to clipboard!');
          });
        } catch (err) {
          this.showNotification('‚úó Failed to copy. Try downloading instead.');
        }
      }

      downloadImage() {
        const link = document.createElement('a');
        link.download = `screenshot-${Date.now()}.png`;
        link.href = this.canvas.toDataURL();
        link.click();
        this.showNotification('‚úì Downloaded!');
      }

      loadNewImage() {
        if (confirm('Load a new image? Current edits will be lost.')) {
          this.canvas.classList.add('hidden');
          this.toolbar.classList.add('hidden');
          this.dropZone.classList.remove('hidden');
          this.undoStack = [];
          this.redoStack = [];
        }
      }

      showNotification(message) {
        const notification = document.createElement('div');
        notification.textContent = message;
        notification.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: #333;
          color: white;
          padding: 16px 24px;
          border-radius: 8px;
          font-weight: 500;
          z-index: 1000;
          animation: slideIn 0.3s ease;
        `;
        document.body.appendChild(notification);
        
        setTimeout(() => {
          notification.style.animation = 'slideOut 0.3s ease';
          setTimeout(() => notification.remove(), 300);
        }, 2000);
      }
    }

    const editor = new ScreenshotEditor();
  </script>
</body>
</html>